import esbuild from "esbuild";
import process from "process";
import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);
const __dirname = path.dirname(new URL(import.meta.url).pathname);

// Plugin to resolve @/ path alias to src/
const aliasPlugin = {
  name: 'alias-resolver',
  setup(build) {
    // Resolve @/* imports to src/*
    build.onResolve({ filter: /^@\// }, (args) => {
      const resolvedPath = path.resolve(__dirname, 'src', args.path.slice(2));

      // Try to resolve the path with different extensions
      const extensions = ['.ts', '.tsx', '.js', '.jsx'];

      // First, check if the path exists as-is (with extension already)
      if (fileExists(resolvedPath)) {
        return { path: resolvedPath };
      }

      // Try adding extensions
      for (const ext of extensions) {
        const pathWithExt = resolvedPath + ext;
        if (fileExists(pathWithExt)) {
          return { path: pathWithExt };
        }
      }

      // Try index files for directory imports
      if (fs.existsSync(resolvedPath) && fs.statSync(resolvedPath).isDirectory()) {
        for (const ext of extensions) {
          const indexPath = path.join(resolvedPath, 'index' + ext);
          if (fileExists(indexPath)) {
            return { path: indexPath };
          }
        }
      }

      // Fallback to the resolved path (might fail later)
      return { path: resolvedPath };
    });
  }
};

// Production mode by default, development only with explicit flag
const isDevelopment = process.argv.includes("--development");
const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository of this plugin
*/
`;

const fileExists = (filePath) => {
  try {
    return fs.statSync(filePath).isFile();
  } catch (e) {
    return false;
  }
};


// Plugin to prevent Node.js modules
const preventNodeModulesPlugin = {
  name: 'prevent-node-modules',
  setup(build) {
    // Filter to warn about Node.js modules
    build.onResolve({ filter: /^(node:)?(fs|path|os|crypto|buffer|stream|util|events|url|child_process|module)$/ }, (args) => {
      console.warn(`⚠️  Attempted to import Node.js module: ${args.path}. This is not allowed in browser builds.`);
      return { external: true };
    });
  }
};

/**
 * Builds a worker file into a string.
 * This is done in memory and the result is used in the main build.
 * @param {string} entryPoint - The path to the worker entry file.
 * @returns {Promise<string>} A promise that resolves to the bundled worker code.
 */
async function buildWorkerCode(entryPoint) {
  if (!fileExists(entryPoint)) {
    console.warn(`Worker entry point not found: ${entryPoint}, skipping worker build.`);
    return "";
  }

  const result = await esbuild.build({
    entryPoints: [entryPoint],
    bundle: true,
    minify: !isDevelopment, // Only minify in production
    platform: "browser", // Browser by default
    format: 'iife', // self-contained immediate-invoked function expression
    write: false,  // output to memory instead of a file
    // Support for TypeScript decorators
    tsconfigRaw: {
      compilerOptions: {
        experimentalDecorators: true,
        emitDecoratorMetadata: true,
        useDefineForClassFields: true,
      },
    },
    // Ensure no development code gets bundled
    define: {
      "process.env.NODE_ENV": JSON.stringify(isDevelopment ? "development" : "production"),
      "global": "window",
      "__filename": "'worker.js'", // Mock Node.js globals
      "__dirname": "'.'",
      "Buffer": "undefined",
    },
    // Ensure tree shaking removes development-only code
    treeShaking: true,
    // Strict browser-only conditions
    mainFields: ["browser", "module", "main"],
    conditions: isDevelopment ? ["browser", "development"] : ["browser", "production"],
    // Prevent Node.js modules from being bundled
    external: ["node:*", "fs", "path", "os", "crypto", "buffer", "stream", "util", "events", "url"],
    // Mark Node.js packages as external
//    packages: "external",
    // Add plugins for worker builds too
    plugins: [aliasPlugin, preventNodeModulesPlugin],
  });

  if (result.outputFiles && result.outputFiles.length > 0) {
    return result.outputFiles[0].text;
  }
  throw new Error(`esbuild did not produce an output file for the worker: ${entryPoint}`);
}

/**
 * Creates the final esbuild options, injecting the worker code.
 * @returns {Promise<import('esbuild').BuildOptions>} A promise that resolves to the build options.
 */
async function createBuildOptions() {
  // 1. Build the workers and get their code as strings.
  const diffWorkerCode = await buildWorkerCode('src/workers/diff.worker.ts');
  const timelineWorkerCode = await buildWorkerCode('src/workers/timeline/index.ts');
  const editHistoryWorkerCode = await buildWorkerCode('src/workers/edit-history/index.ts');
  const compressionWorkerCode = await buildWorkerCode('src/workers/compression.worker.ts');

  const entryPoints = ["src/main/index.ts"];
  if (fileExists("src/styles.css")) {
    entryPoints.push("src/styles.css");
  }

  const buildOptions = {
    banner: { js: banner },
    entryPoints,
    bundle: true,
    platform: "browser", // Browser by default
    format: "cjs",
    target: "es2020",
    logLevel: "info",
    sourcemap: false,
    treeShaking: true, // Ensures unused code (including dev code) is removed
    minify: !isDevelopment,
    minifyWhitespace: !isDevelopment,
    minifyIdentifiers: !isDevelopment,
    minifySyntax: !isDevelopment,
    outdir: ".",
    // JSX configuration for React 17+ automatic runtime
    jsx: "automatic",
    loader: {
      '.tsx': 'tsx',
      '.ts': 'ts',
    },
    // Support for TypeScript decorators
    tsconfigRaw: {
      compilerOptions: {
        experimentalDecorators: true,
        emitDecoratorMetadata: true,
        useDefineForClassFields: true,
      },
    },
    // 2. Define the global constants. `JSON.stringify` ensures the code is correctly
    // escaped and wrapped in quotes to be a valid string in the final bundle.
    define: {
      "diffWorkerString": JSON.stringify(diffWorkerCode),
      "timelineWorkerString": JSON.stringify(timelineWorkerCode),
      "editHistoryWorkerString": JSON.stringify(editHistoryWorkerCode),
      "compressionWorkerString": JSON.stringify(compressionWorkerCode),
      // Ensure production mode for libraries that use process.env.NODE_ENV
      "process.env.NODE_ENV": JSON.stringify(isDevelopment ? "development" : "production"),
      "global": "window", // Ensure browser globals
      "__filename": "'main.js'", // Mock Node.js globals to prevent crashes
      "__dirname": "'.'",
      "Buffer": "undefined", // Remove Node.js Buffer
      "process": "undefined", // Remove Node.js process object
    },
    // Additional settings to prevent bundling dev code
    legalComments: "none", // Remove legal comments in production
    // Strict browser-only conditions
    mainFields: ["browser", "module", "main"],
    conditions: isDevelopment ? ["browser", "development"] : ["browser", "production"],
    // Prevent Node.js modules from being bundled
    external: ["obsidian", "node:*", "fs", "path", "os", "crypto", "buffer", "stream", "util", "events", "url", "child_process", "module"],
    // Mark Node.js packages as external
//    packages: "external",
    // Ensure no Node.js polyfills are included
    inject: [],
    // Add both plugins
    plugins: [aliasPlugin, preventNodeModulesPlugin],
  };

  return buildOptions;
}

// Function to run tsc --noEmit and log errors without halting build
async function typeCheck() {
  try {
    const { stdout, stderr } = await execAsync("npx tsc --noEmit --skipLibCheck true");
    
    if (stdout.trim() || stderr.trim()) {
      console.error("TypeScript type errors detected:");
      if (stdout.trim()) console.error(stdout);
      if (stderr.trim()) console.error(stderr);
      console.error("\n⚠️  Type errors found, but continuing with build...");
    } else {
      console.log("✓ Type check passed");
    }
  } catch (error) {
    if (error.stdout || error.stderr) {
      console.error("TypeScript type errors detected:");
      if (error.stdout.trim()) console.error(error.stdout);
      if (error.stderr.trim()) console.error(error.stderr);
      console.error("\n⚠️  Type errors found, but continuing with build...");
    } else {
      console.error("TypeScript check failed:", error.message);
    }
  }
}

// Main build execution
async function runBuild() {
  console.log(`Building in ${isDevelopment ? "development" : "production"} mode...`);
  
  // Run type check first and WAIT for it to complete before starting build
  await typeCheck();
  
  const options = await createBuildOptions();
  
  // Always build (no watch mode)
  try {
    console.log("Starting esbuild...");
    await esbuild.build(options);
    console.log("✓ Build completed successfully");
  } catch (error) {
    console.error("Build process failed:", error);
    process.exit(1);
  }
}

// Run the build
runBuild().catch(error => {
    console.error("Build process failed:", error);
    process.exit(1);
});
