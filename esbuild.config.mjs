import esbuild from "esbuild";
import process from "process";
import fs from "fs";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);
const __dirname = path.dirname(new URL(import.meta.url).pathname);

// Production mode by default, development only with explicit flag
const isDevelopment = process.argv.includes("--development");
const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository of this plugin
*/
`;

const fileExists = (filePath) => {
  try {
    return fs.statSync(filePath).isFile();
  } catch (e) {
    return false;
  }
};

// Plugin to resolve zod/v4/core for @hookform/resolvers compatibility
const zodAliasPlugin = {
  name: 'zod-alias',
  setup(build) {
    build.onResolve({ filter: /^zod\/v4\/core$/ }, () => {
      return { 
        path: path.resolve(__dirname, 'node_modules', 'zod', 'v4', 'core', 'index.cjs') 
      };
    });
  },
};

// Plugin to prevent Node.js modules
const preventNodeModulesPlugin = {
  name: 'prevent-node-modules',
  setup(build) {
    // Filter to warn about Node.js modules
    build.onResolve({ filter: /^(node:)?(fs|path|os|crypto|buffer|stream|util|events|url|child_process|module)$/ }, (args) => {
      console.warn(`⚠️  Attempted to import Node.js module: ${args.path}. This is not allowed in browser builds.`);
      return { external: true };
    });
  }
};

/**
 * Builds a worker file into a string.
 * This is done in memory and the result is used in the main build.
 * @param {string} entryPoint - The path to the worker entry file.
 * @returns {Promise<string>} A promise that resolves to the bundled worker code.
 */
async function buildWorkerCode(entryPoint) {
  if (!fileExists(entryPoint)) {
    console.warn(`Worker entry point not found: ${entryPoint}, skipping worker build.`);
    return "";
  }

  const result = await esbuild.build({
    entryPoints: [entryPoint],
    bundle: true,
    minify: !isDevelopment, // Only minify in production
    platform: "browser", // Browser by default
    format: 'iife', // self-contained immediate-invoked function expression
    write: false,  // output to memory instead of a file
    // Ensure no development code gets bundled
    define: {
      "process.env.NODE_ENV": JSON.stringify(isDevelopment ? "development" : "production"),
      "global": "window",
      "__filename": "'worker.js'", // Mock Node.js globals
      "__dirname": "'.'",
      "Buffer": "undefined",
    },
    // Ensure tree shaking removes development-only code
    treeShaking: true,
    // Strict browser-only conditions
    mainFields: ["browser", "module", "main"],
    conditions: isDevelopment ? ["browser", "development"] : ["browser", "production"],
    // Prevent Node.js modules from being bundled
    external: ["node:*", "fs", "path", "os", "crypto", "buffer", "stream", "util", "events", "url"],
    // Mark Node.js packages as external
//    packages: "external",
    // Add plugins for worker builds too
    plugins: [zodAliasPlugin, preventNodeModulesPlugin],
  });

  if (result.outputFiles && result.outputFiles.length > 0) {
    return result.outputFiles[0].text;
  }
  throw new Error(`esbuild did not produce an output file for the worker: ${entryPoint}`);
}

/**
 * Creates the final esbuild options, injecting the worker code.
 * @returns {Promise<import('esbuild').BuildOptions>} A promise that resolves to the build options.
 */
async function createBuildOptions() {
  // 1. Build the workers and get their code as strings.
  const diffWorkerCode = await buildWorkerCode('src/workers/diff.worker.ts');
  const timelineWorkerCode = await buildWorkerCode('src/workers/timeline.worker.ts');
  const editHistoryWorkerCode = await buildWorkerCode('src/workers/edit-history.worker.ts');
  const compressionWorkerCode = await buildWorkerCode('src/workers/compression.worker.ts');

  const entryPoints = ["src/main.ts"];
  if (fileExists("src/styles.css")) {
    entryPoints.push("src/styles.css");
  }

  const buildOptions = {
    banner: { js: banner },
    entryPoints,
    bundle: true,
    platform: "browser", // Browser by default
    format: "cjs",
    target: "es2020",
    logLevel: "info",
    sourcemap: false,
    treeShaking: true, // Ensures unused code (including dev code) is removed
    minify: !isDevelopment,
    minifyWhitespace: !isDevelopment,
    minifyIdentifiers: !isDevelopment,
    minifySyntax: !isDevelopment,
    outdir: ".",
    // 2. Define the global constants. `JSON.stringify` ensures the code is correctly
    // escaped and wrapped in quotes to be a valid string in the final bundle.
    define: {
      "diffWorkerString": JSON.stringify(diffWorkerCode),
      "timelineWorkerString": JSON.stringify(timelineWorkerCode),
      "editHistoryWorkerString": JSON.stringify(editHistoryWorkerCode),
      "compressionWorkerString": JSON.stringify(compressionWorkerCode),
      // Ensure production mode for libraries that use process.env.NODE_ENV
      "process.env.NODE_ENV": JSON.stringify(isDevelopment ? "development" : "production"),
      "global": "window", // Ensure browser globals
      "__filename": "'main.js'", // Mock Node.js globals to prevent crashes
      "__dirname": "'.'",
      "Buffer": "undefined", // Remove Node.js Buffer
      "process": "undefined", // Remove Node.js process object
    },
    // Additional settings to prevent bundling dev code
    legalComments: "none", // Remove legal comments in production
    // Strict browser-only conditions
    mainFields: ["browser", "module", "main"],
    conditions: isDevelopment ? ["browser", "development"] : ["browser", "production"],
    // Prevent Node.js modules from being bundled
    external: ["obsidian", "node:*", "fs", "path", "os", "crypto", "buffer", "stream", "util", "events", "url", "child_process", "module"],
    // Mark Node.js packages as external
//    packages: "external",
    // Ensure no Node.js polyfills are included
    inject: [],
    // Add both plugins
    plugins: [zodAliasPlugin, preventNodeModulesPlugin],
  };

  return buildOptions;
}

// Function to run tsc --noEmit and log errors without halting build
async function typeCheck() {
  try {
    const { stdout, stderr } = await execAsync("npx tsc --noEmit --skipLibCheck true");
    
    if (stdout.trim() || stderr.trim()) {
      console.error("TypeScript type errors detected:");
      if (stdout.trim()) console.error(stdout);
      if (stderr.trim()) console.error(stderr);
      console.error("\n⚠️  Type errors found, but continuing with build...");
    } else {
      console.log("✓ Type check passed");
    }
  } catch (error) {
    if (error.stdout || error.stderr) {
      console.error("TypeScript type errors detected:");
      if (error.stdout.trim()) console.error(error.stdout);
      if (error.stderr.trim()) console.error(error.stderr);
      console.error("\n⚠️  Type errors found, but continuing with build...");
    } else {
      console.error("TypeScript check failed:", error.message);
    }
  }
}

// Main build execution
async function runBuild() {
  console.log(`Building in ${isDevelopment ? "development" : "production"} mode...`);
  
  // Run type check first and WAIT for it to complete before starting build
  await typeCheck();
  
  const options = await createBuildOptions();
  
  // Always build (no watch mode)
  try {
    console.log("Starting esbuild...");
    await esbuild.build(options);
    console.log("✓ Build completed successfully");
  } catch (error) {
    console.error("Build process failed:", error);
    process.exit(1);
  }
}

// Run the build
runBuild().catch(error => {
    console.error("Build process failed:", error);
    process.exit(1);
});
